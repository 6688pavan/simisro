# Telemetry Simulator - Complete Application Logic Documentation

## Table of Contents

1. [Application Overview](#application-overview)
2. [Architecture & Components](#architecture--components)
3. [Data Flow & Threading Model](#data-flow--threading-model)
4. [Core Components Deep Dive](#core-components-deep-dive)
5. [GUI Components & Interactions](#gui-components--interactions)
6. [File I/O & Parameter Management](#file-io--parameter-management)
7. [Network Transmission](#network-transmission)
8. [Waveform Generation System](#waveform-generation-system)
9. [Real-time Plotting & Visualization](#real-time-plotting--visualization)
10. [Error Handling & Logging](#error-handling--logging)
11. [Configuration & State Management](#configuration--state-management)
12. [Simulation Control & Timing Logic](#simulation-control--timing-logic)

## Application Overview

The Telemetry Simulator is a PyQt5-based desktop application that generates synthetic telemetry data by mimicking a launch vehicle's telemetry log. It loads binary .dat files containing embedded parameter definitions and binary data, selectively overwrites parameters with waveform-based or fixed values, and transmits records via UDP multicast. The GUI provides real-time visualization, parameter configuration, and simulation control.

### Key Features

- **Embedded Parameter Support**: Load .dat files with embedded parameter definitions (no external CSV required)
- **Dual Cycle Support**: Generate data for major cycle (1 sample) and minor cycle (5 samples) parameters
- **Configurable Transmission**: Transmit records at configurable rates (1, 2, 5, 10, 50 Hz) via UDP multicast
- **Real-time Visualization**: Live plotting of enabled parameters with moving markers
- **Parameter Management**: Add, edit, and remove parameters with custom timing windows
- **State Persistence**: JSON export/import of simulation state (parameters, time range, Hz)
- **Threaded Architecture**: Non-blocking GUI operation with synchronized pause/resume
- **Manual Parameter Creation**: Create parameters without .dat files for testing

## Architecture & Components

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    GUI Layer (PyQt5)                        │
├─────────────────────────────────────────────────────────────┤
│  MainWindow │ ParameterTable │ WaveformPlot │ ParameterEditor │
├─────────────────────────────────────────────────────────────┤
│                    Threading Layer                          │
├─────────────────────────────────────────────────────────────┤
│  SeederThread │ SenderThread                                │
├─────────────────────────────────────────────────────────────┤
│                    Core Logic Layer                         │
├─────────────────────────────────────────────────────────────┤
│  SeedingEngine │ PacketBuffer │ Loader │ ConfigManager      │
├─────────────────────────────────────────────────────────────┤
│                    Data Models                              │
├─────────────────────────────────────────────────────────────┤
│  Parameter │ ParameterList │ RecordSpec │ WaveformGenerators │
└─────────────────────────────────────────────────────────────┘
```

### Component Responsibilities

#### GUI Components
- **MainWindow**: Central controller orchestrating UI, threads, and core logic
- **ParameterTableWidget**: Displays parameter list with real-time updates and graph enable/disable
- **WaveformPlotWidget**: Real-time plotting using pyqtgraph with marker tracking
- **ParameterEditorDialog**: Modal dialog for adding/editing parameters with tabbed interface

#### Core Logic
- **SeedingEngine**: Generates parameter values and packs into records
- **PacketBuffer**: Manages 10 × 1400-byte packet buffers with efficient data operations
- **Loader**: Reads .dat files with embedded parameters or legacy binary-only format
- **ConfigManager**: Handles JSON export/import of simulation state

#### Threading
- **SeederThread**: Generates records at specified Hz with proper timing
- **SenderThread**: Transmits packets via UDP multicast with queue management

#### Data Models
- **Parameter**: Core parameter definition with all configuration options
- **ParameterList**: Container for parameter management operations
- **RecordSpec**: Configuration for packet structure and timing

## Data Flow & Threading Model

### Complete Data Flow

1. **Initialization**
   - Load .dat file (binary record snapshot with embedded parameters)
   - Configure simulation settings (start/end time, Hz, multicast IP/port)
   - Initialize parameter table and waveform plot

2. **Simulation Start**
   - Create SeederThread with parameter getter and timing configuration
   - Create SenderThread with network configuration
   - Connect signal chains for data flow and GUI updates

3. **Record Generation**
   - SeederThread advances simulation timer by (1.0 / Hz) per record
   - For each enabled parameter:
     - Major cycle: Set fixed value at record_time
     - Minor cycle: Compute 5 waveform samples (100ms spacing)
   - Copy unseeded parameters from .dat (if available)
   - Update time field in all packets
   - Emit record_ready signal with packets

4. **Transmission & Visualization**
   - SenderThread receives packets via enqueue method
   - Send packets via UDP multicast
   - Update GUI: parameter table, waveform plot, statistics
   - Log events and handle errors
   - Stop when timer reaches end time

## Seeding Mechanism Deep Dive

### What we seed

- **Analog parameters (dtype = "float")**:
  - Major cycle: 1 float sample per record (4 bytes) at `record_time`.
  - Minor cycle: 5 float samples per record (5 × 4 bytes), at times `record_time + i * Δt`.
- **Digital parameters (dtype = "bit")**:
  - Major cycle: Single unsigned value at `record_time` with bit-width 8/16/32 bits.
  - Minor cycle: 5 discrete samples per record, each stored as an 8‑byte slot (uint64) to align with existing packet layout while only the low 8 bits carry data.

Each parameter specifies: `packet_id` (which packet within the record), `offset` (byte offset inside the packet), `samples_per_500ms` (1 for major, 5 for minor), waveform and limits, and an optional fixed value (for major analog).

### When we seed

- The simulation runs at `Hz` records per second; the time increment per record is `ΔT = 1 / Hz`.
- For minor‑cycle parameters, the 5 intra‑record samples are spread uniformly across the record time window:
  - `sample_time_i = record_time + i * (ΔT / 5)` for `i in [0..4]`.
- For legacy logic described earlier, some views reference 100ms spacing; the actual implementation adapts spacing based on `Hz` via `ΔT / 5` so timing stays consistent across rates.

### How we seed (end‑to‑end)

1. `SeederThread.run()` advances `current_time` by `ΔT` and calls:
   - `SeedingEngine.seed_record(params, record_time, dat_buffer, ΔT)`
2. `SeedingEngine.seed_record` creates a `PacketBuffer` holding 10 packets × 1400 bytes (default) for the record.
   - If a `.dat` snapshot is present, it is split into 10 × 1400‑byte packet images and used as the starting memory for the record; otherwise, a zero‑initialized record is used.
   - The record time (float, little‑endian `<f`) is stored once per record at absolute offset 24 (i.e., packet 0 @ offset 24).
3. For each enabled parameter active at `record_time`:
   - Major analog: compute `value = fixed_value` (or 0.0) and `insert_float(packet_id, offset, value)`.
   - Major digital: threshold a waveform at `record_time` to choose min/max; insert as uint8/uint16/uint32 at `offset`.
   - Minor analog: for `i=0..4`, compute `t_i = record_time + i * (ΔT / 5)`, evaluate waveform in `[min_v, max_v]`, and `insert_float(packet_id, offset + i*4, value_i)`.
   - Minor digital: for `i=0..4`, compute a min/max toggle at `t_i`, and `insert_uint64(packet_id, offset + i*8, value_i & 0xFF)`.
4. The `PacketBuffer` returns immutable `bytes` for each packet; `SeederThread` emits `record_ready(record_idx, record_time, packets)` containing exactly 10 packet blobs.
5. `SenderThread.enqueue(...)` receives that record and queues it for transmission.

### Memory layout of a record

- A record is a contiguous 14,000‑byte region (10 packets × 1400 bytes), conceptually split into 10 packets for transport.
- The record timestamp is stored once per record at the absolute offset 24 (i.e., in packet 0 at offset 24) as a 4‑byte little‑endian float `<f`.
- Parameter data occupies configured positions relative to their packet and offset; absolute address = `packet_id * packet_length + offset (+ intra‑sample stride)`:
  - Float sample: 4 bytes little‑endian `<f`.
  - Digital major: `<B`, `<H`, or `<I` depending on bit‑width.
  - Digital minor: 5 slots of 8 bytes each `<Q` at `offset + i*8` with only the low byte used.

### Packetization and UDP transmission

- `SenderThread` maintains a queue of records. In its loop it pops a record, then iterates over 10 packet slices of the contiguous 14,000‑byte record and calls `socket.sendto(packet, (group, port))` for each.
- It updates counters: `packet_sent`, `record_sent`, and cumulative `bytes_sent_signal`.
- Pausing/resuming only affects processing of the queue; the buffered records remain intact.

### Why 10 packets per record?

- The simulator models a fixed‑width record composed of 10 equal‑sized packets for predictable layout and transport pacing. This also allows GUI stats like "Packets/Record" to remain constant and simplifies buffer math (packet_id × length + offset).

## Directory Map and Roles

- `main.py`: Application entry point; creates `QApplication`, instantiates and shows `MainWindow`.
- `gui/main_window.py`: Orchestrates UI, starts/stops threads, connects signals, updates statistics and plot.
- `gui/widgets/param_table.py`: Displays parameters, lengths derived from dtype and cycle, shows instantaneous values/timestamps.
- `gui/widgets/waveform_plot.py`: Real‑time plotting of enabled parameters; manages curves and marker.
- `gui/parameter_editor.py`: Dialog for creating/editing parameters (basic, waveform, timing tabs).
- `core/seeder.py`: `SeedingEngine` implementation that seeds parameters into a `PacketBuffer` and emits per‑parameter samples for the UI.
- `core/packet_buffer.py`: Low‑level byte insertions, record time writing, and conversion to immutable packet bytes.
- `core/loader.py`: Loads `.dat` snapshots with embedded parameters (or legacy binary), and CSV parameter definitions.
- `core/models.py`: Data classes for `Parameter` definitions and related structures.
- `core/waveform.py`: Waveform factory and evaluators (Sine, Triangle, Square, Step, Noise).
- `threads/seeder_thread.py`: QThread that advances time and calls `SeedingEngine.seed_record` at the configured Hz.
- `threads/sender_thread.py`: QThread that dequeues records and multicasts each packet; reports stats.
- `threads/worker_signals.py`: Shared Qt signals container (used in some tests/docs).
- `utils/config.py`: Save/load JSON configs (simulation settings + parameters).
- `utils/json_helpers.py`, `utils/io_helpers.py`, `utils/validators.py`, `utils/file_handler.py`, `utils/time_utils.py`: Misc utilities used across the app.
- `scripts/*.py`: Test and demonstration scripts for timing, plotting, restart behavior, and parameter seeding.

## Runtime Sequence (when running main.py)

1. `python main.py` → `main()` creates a `QApplication`, applies Fusion style, creates `MainWindow`, shows it, and enters the Qt event loop.
2. In `MainWindow`, you load parameters and (optionally) a `.dat` file snapshot.
3. On Start:
   - Reads UI inputs: multicast group/port, start/end time, Hz.
   - Creates and starts `SenderThread` (configures UDP socket).
   - Creates `SeederThread` with `params_getter`, `seeding_engine`, `dat_buffer`, and timing.
   - Connects signals:
     - `seeder.record_ready` → `sender.enqueue`, `on_record_ready`, `update_current_time`.
     - `sender.record_sent` → `update_records_sent`.
     - `sender.bytes_sent_signal` → `_update_bytes_sent`.
   - Starts `SeederThread`.
4. Looping runtime:
   - `SeederThread` produces one record every `ΔT = 1/Hz` seconds.
   - `SenderThread` consumes queued records and multicasts each of the 10 packets.
   - GUI updates stats/plot via Qt signals.
5. Pause/Resume/Reset:
   - Pause toggles both threads to stop advancing time or consuming the queue.
   - Resume continues from current time with the same Hz (or updated via UI).
   - Reset stops both threads, clears GUI state, and returns to the initial screen.


### Threading Architecture

#### SeederThread (Data Generation)
```python
def run(self):
    self.running = True
    current_time = self.start_time
    record_idx = 0
    while self.running and current_time <= self.end_time:
        if self.paused:
            time.sleep(0.05)
            continue
        try:
            buffer = self.seeding_engine.seed_record(
                self.params_getter(), current_time, self.dat_buffer)
            packets = buffer.get_packets()
            self.record_ready.emit(record_idx, current_time, packets)
            record_idx += 1
            sleep_time = 1.0 / self.hz
            time.sleep(sleep_time)
            current_time += 1.0 / self.hz
        except Exception as e:
            self.error.emit(str(e))
```

#### SenderThread (Data Transmission)
```python
def run(self):
    self.running = True
    self.configure_socket()
    while self.running:
        if self.paused:
            self.msleep(50)
            continue
        if not self._queue:
            self.msleep(1)
            continue
        
        # Process all available records
        while self._queue and self.running and not self.paused:
            record_idx, packets = self._queue.pop(0)
            bytes_sent = 0
            for i, pkt in enumerate(packets):
                self.sock.sendto(pkt, (self.group, int(self.port)))
                bytes_sent += len(pkt)
            self.total_bytes += bytes_sent
            self.bytes_sent_signal.emit(self.total_bytes)
            self.record_sent.emit(record_idx, time.time())
```

### Signal Communication
```python
# Main signal connections
seeder_thread.record_ready.connect(sender_thread.enqueue)
seeder_thread.record_ready.connect(main_window.on_record_ready)
seeder_thread.record_ready.connect(main_window.update_current_time)
seeder_thread.error.connect(main_window.log.append)
sender_thread.record_sent.connect(main_window.update_records_sent)
sender_thread.bytes_sent_signal.connect(main_window._update_bytes_sent)
```

## Core Components Deep Dive

### 1. Parameter Model (core/models.py)

```python
@dataclass
class Parameter:
    sl_no: int = 0
    name: str = "param"
    packet_id: int = 0
    offset: int = 0
    dtype: str = "float"  # 'float' or 'bit'
    min_v: float = 0.0
    max_v: float = 1.0
    waveform: str = "Sine"  # Sine, Triangle, Square, Step, Noise
    freq: float = 1.0
    phase: float = 0.0
    full_sweep: bool = True
    samples_per_500ms: int = 1  # 5 for minor cycle, 1 for major
    enabled_in_graph: bool = False
    enabled: bool = True  # For seeding
    start_time: float = None  # Custom seeding window
    end_time: float = None
    fixed_value: float = None  # For major cycle

    def to_dict(self):
        return vars(self)

    @classmethod
    def from_dict(cls, d):
        return cls(**d)
```

### 2. SeedingEngine (core/seeder.py)

```python
class SeedingEngine:
    def __init__(self, packet_length=1400, packets_per_record=10, time_field_offset=24):
        self.packet_length = packet_length
        self.packets_per_record = packets_per_record
        self.time_field_offset = time_field_offset

    def seed_record(self, params, record_time, dat_buffer=None):
        buffer = PacketBuffer(self.packet_length, self.packets_per_record, self.time_field_offset)
        if dat_buffer is not None:
            buffer.buffers = [bytearray(b) for b in dat_buffer]
        else:
            buffer.reset()
        buffer.set_record_time(record_time)

        for param in params:
            if not param.enabled or record_time < param.start_time or record_time > param.end_time:
                continue
            if param.samples_per_500ms == 1:  # Major cycle
                value = param.fixed_value if param.fixed_value is not None else 0.0
                if param.dtype == "float":
                    buffer.insert_float(param.packet_id, param.offset, value)
                else:  # Digital
                    if param.bit_width == 8:
                        buffer.insert_uint8(param.packet_id, param.offset, int(value))
                    elif param.bit_width == 16:
                        buffer.insert_uint16(param.packet_id, param.offset, int(value))
                    else:  # 32 bits
                        buffer.insert_uint32(param.packet_id, param.offset, int(value))
                if param.enabled_in_graph:
                    self.sample_generated.emit(param.name, value, record_time)
            else:  # Minor cycle (5 samples)
                wf = make_waveform(param.waveform, param.freq, param.phase, param.full_sweep)
                sample_values = []
                for i in range(5):
                    sample_time = record_time + i * 0.1  # 100ms spacing
                    value = wf.value(sample_time, param.min_v, param.max_v)
                    sample_values.append(value)
                    offset = param.offset + (i * 4 if param.dtype == "float" else i * 8)
                    if param.dtype == "float":
                        buffer.insert_float(param.packet_id, offset, value)
                    else:
                        buffer.insert_uint64(param.packet_id, offset, int(value) & 0xFF)  # 8-bit value in 8 bytes
                if param.enabled_in_graph:
                    self.sample_generated.emit(param.name, sample_values, record_time)
        return buffer
```

### 3. Waveform Generators (core/waveform.py)

```python
def make_waveform(waveform_type, freq, phase, full_sweep):
    class BaseWaveform:
        def value(self, t, min_v, max_v):
            norm = self._compute(t)  # Returns [-1, 1]
            return min_v + (max_v - min_v) * (norm + 1) / 2

    class Sine(BaseWaveform):
        def _compute(self, t):
            return math.sin(2 * math.pi * freq * t + phase)

    class Triangle(BaseWaveform):
        def _compute(self, t):
            period = 1 / freq
            frac = math.fmod(t + phase / (2 * math.pi), period) / period
            return -1 + 4 * frac if frac < 0.5 else 3 - 4 * frac

    class Square(BaseWaveform):
        def _compute(self, t):
            return math.copysign(1, math.sin(2 * math.pi * freq * t + phase))

    class Step(BaseWaveform):
        def _compute(self, t):
            return 1 if math.sin(2 * math.pi * freq * t + phase) > 0 else -1

    class Noise(BaseWaveform):
        def _compute(self, t):
            return random.uniform(-1, 1)

    return {
        "Sine": Sine,
        "Triangle": Triangle,
        "Square": Square,
        "Step": Step,
        "Noise": Noise
    }.get(waveform_type, Sine)()
```

### 4. Packet Buffer (core/packet_buffer.py)

```python
class PacketBuffer:
    def __init__(self, packet_length=1400, packets_per_record=10, time_field_offset=24):
        self.packet_length = int(packet_length)
        if self.packet_length % 4 != 0:
            self.packet_length += (4 - self.packet_length % 4)
        self.packets_per_record = int(packets_per_record)
        self.time_field_offset = int(time_field_offset)
        self.reset()

    def reset(self):
        self.buffers = [bytearray(self.packet_length) for _ in range(self.packets_per_record)]

    def insert_float(self, packet_id, offset, value):
        if 0 <= packet_id < self.packets_per_record and offset + 4 <= self.packet_length:
            self.buffers[packet_id][offset:offset+4] = struct.pack('<f', float(value))
            return True
        return False

    def insert_uint8(self, packet_id, offset, value):
        if 0 <= packet_id < self.packets_per_record and offset < self.packet_length:
            self.buffers[packet_id][offset] = value & 0xFF
            return True
        return False

    def insert_uint16(self, packet_id, offset, value):
        if 0 <= packet_id < self.packets_per_record and offset + 2 <= self.packet_length:
            self.buffers[packet_id][offset:offset+2] = struct.pack('<H', value & 0xFFFF)
            return True
        return False

    def insert_uint32(self, packet_id, offset, value):
        if 0 <= packet_id < self.packets_per_record and offset + 4 <= self.packet_length:
            self.buffers[packet_id][offset:offset+4] = struct.pack('<I', value & 0xFFFFFFFF)
            return True
        return False

    def insert_uint64(self, packet_id, offset, value):
        if 0 <= packet_id < self.packets_per_record and offset + 8 <= self.packet_length:
            self.buffers[packet_id][offset:offset+8] = struct.pack('<Q', value & 0xFF)
            return True
        return False

    def set_record_time(self, record_time):
        b = struct.pack('<f', float(record_time))
        for buf in self.buffers:
            if self.time_field_offset + 4 <= self.packet_length:
                buf[self.time_field_offset:self.time_field_offset+4] = b

    def get_packets(self):
        return [bytes(b) for b in self.buffers]
```

## GUI Components & Interactions

### 1. MainWindow (gui/main_window.py)

#### UI Layout
- **Top Bar**: Start, Pause, Resume, Reset, Export Config, Load Config, Browse File buttons
- **Top Panes (QGridLayout)**:
  - Left: Start/End Time (-900s to 1200s), Transmission Hz (1, 2, 5, 10, 50)
  - Middle: Live Stats (Current Time, Records Sent, Bytes Sent, Packets/Record)
  - Right: Multicast IP (default "239.0.0.1"), Port (default "12345")
- **Middle (QSplitter)**:
  - Left: Parameter table with Add/Edit/Remove buttons
  - Right: Waveform plot with Graph Options button
- **Bottom**: Log view (QTextEdit, read-only)

#### Signal Connections
```python
def connect_signals(self):
    self.start_btn.clicked.connect(self.on_start)
    self.pause_btn.clicked.connect(self.on_pause)
    self.resume_btn.clicked.connect(self.on_resume)
    self.stop_btn.clicked.connect(self.on_reset)
    self.export_btn.clicked.connect(self.on_export_config)
    self.load_btn.clicked.connect(self.on_load_config)
    self.browse_btn.clicked.connect(self.on_browse_file)
    self.add_param_btn.clicked.connect(self.on_add_param)
    self.edit_param_btn.clicked.connect(self.on_edit_param)
    self.remove_param_btn.clicked.connect(self.on_remove_param)
    self.graph_options_btn.clicked.connect(self.waveform_plot._show_graph_popup)
```

#### Simulation Control
```python
def on_start(self):
    if not self.parameters:
        self.log.append("No parameters loaded")
        return
    
    # Allow simulation without .dat file
    if not self.dat_buffer:
        self.log.append("No .dat file loaded - using empty buffers for simulation")
    
    # Create and start threads
    ip = self.multicast_ip_edit.text()
    port = int(self.port_edit.text())
    self.sender_thread = SenderThread(group=ip, port=port)
    self.sender_thread.start()
    
    start_time = float(self.start_time_edit.text())
    end_time = float(self.end_time_edit.text())
    hz = float(self.hz_combo.currentText())
    
    self.seeder_thread = SeederThread(
        params_getter=lambda: self.parameters,
        seeding_engine=self.seeding_engine,
        dat_buffer=self.dat_buffer,
        start_time=start_time,
        end_time=end_time,
        hz=hz
    )
    
    # Connect signals
    self.seeder_thread.record_ready.connect(self.sender_thread.enqueue)
    self.seeder_thread.record_ready.connect(self.on_record_ready)
    self.seeder_thread.record_ready.connect(self.update_current_time)
    self.seeder_thread.error.connect(self.log.append)
    self.sender_thread.record_sent.connect(self.update_records_sent)
    self.sender_thread.bytes_sent_signal.connect(self._update_bytes_sent)
    self.seeder_thread.start()
```

### 2. Parameter Table (gui/widgets/param_table.py)

```python
class ParameterTableWidget(QTableWidget):
    HEADERS = ["Enable (Graph)", "Name", "Packet ID", "Type", "Offset", "Length", "Inst. Value", "Time"]

    def __init__(self, parameters_list=None):
        super().__init__(0, len(self.HEADERS))
        self.setHorizontalHeaderLabels(self.HEADERS)
        self.parameters_list = parameters_list

    def add_parameter(self, param):
        r = self.rowCount()
        self.insertRow(r)
        if param.dtype == "float":
            length = 4 * param.samples_per_500ms  # 4 bytes per sample
        else:  # Digital
            length = (param.bit_width // 8 if param.samples_per_500ms == 1 else 8) * param.samples_per_500ms
        values = [
            QTableWidgetItem(""),
            QTableWidgetItem(param.name),
            QTableWidgetItem(str(param.packet_id)),
            QTableWidgetItem(param.dtype),
            QTableWidgetItem(str(param.offset)),
            QTableWidgetItem(str(length)),
            QTableWidgetItem(""),
            QTableWidgetItem("")
        ]
        for c, item in enumerate(values):
            self.setItem(r, c, item)
        checkbox = QCheckBox()
        checkbox.setChecked(param.enabled_in_graph)
        checkbox.stateChanged.connect(lambda state, row=r: self._update_graph_enable(row, state))
        self.setCellWidget(r, 0, checkbox)

    def update_instantaneous(self, name, value, t):
        """Update instantaneous value and time for a parameter (major cycle or minor cycle)"""
        for r in range(self.rowCount()):
            if self.item(r, 1) and self.item(r, 1).text() == name:
                if isinstance(value, list):  # Minor cycle
                    values_text = " | ".join([f"{v:.4g}" for v in value])
                    times_text = " | ".join([f"{t + i*0.1:.3f}" for i in range(5)])
                    self.setItem(r, 6, QTableWidgetItem(values_text))
                    self.setItem(r, 7, QTableWidgetItem(times_text))
                else:  # Major cycle
                    self.setItem(r, 6, QTableWidgetItem(f"{value:.4g}"))
                    self.setItem(r, 7, QTableWidgetItem(f"{t:.3f}"))
                break
```

### 3. Waveform Plot (gui/widgets/waveform_plot.py)

```python
class WaveformPlotWidget(pg.PlotWidget):
    def __init__(self):
        super().__init__()
        self.setBackground('w')
        self.showGrid(x=True, y=True)
        self.setLabel('left', 'Value')
        self.setLabel('bottom', 'Time (s)')
        self.curves = {}  # name -> (plotItem, data_deque)
        self.marker = None

    def update_waveform(self, params, current_time):
        for p in params:
            if p.enabled_in_graph:
                wf = make_waveform(p.waveform, p.freq, p.phase, p.full_sweep)
                
                if p.samples_per_500ms == 1:  # Major cycle - single value
                    y = wf.value(current_time, p.min_v, p.max_v)
                    self.update_sample(p.name, current_time, y)
                    self.set_marker(current_time, y)
                else:  # Minor cycle - 5 samples
                    for i in range(5):
                        sample_time = current_time + i * 0.1
                        y = wf.value(sample_time, p.min_v, p.max_v)
                        self.update_sample(p.name, sample_time, y)
                    
                    first_y = wf.value(current_time, p.min_v, p.max_v)
                    self.set_marker(current_time, first_y)

    def update_sample(self, name, t, y):
        if name not in self.curves:
            self.add_param(name)
        plot, data = self.curves[name]
        data["t"].append(t)
        data["y"].append(y)
        plot.setData(list(data["t"]), list(data["y"]))
```

### 4. Parameter Editor (gui/parameter_editor.py)

The ParameterEditorDialog provides a comprehensive interface for creating and editing parameters with three tabs:

- **Basic Settings**: Name, serial number, packet ID, offset, data type, cycle type, enable flags
- **Waveform**: Waveform type, frequency, phase, min/max values, full sweep, fixed value
- **Timing**: Start time, end time for custom seeding windows

## File I/O & Parameter Management

### 1. File Loading (core/loader.py)

#### New Format (.dat with embedded parameters)
```python
def load_dat(self, filepath):
    with open(filepath, "rb") as f:
        # Read parameter count
        param_count_bytes = f.read(4)
        if len(param_count_bytes) < 4:
            # Old format file, read as binary data only
            f.seek(0)
            return f.read(1400 * 10)
        
        param_count = struct.unpack('<I', param_count_bytes)[0]
        
        # Read parameters
        parameters = []
        for _ in range(param_count):
            # Read parameter name
            name_len_bytes = f.read(4)
            if len(name_len_bytes) < 4:
                break
            name_len = struct.unpack('<I', name_len_bytes)[0]
            name_bytes = f.read(name_len)
            name = name_bytes.decode('utf-8')
            
            # Read parameter data
            packet_id = struct.unpack('<I', f.read(4))[0]
            offset = struct.unpack('<I', f.read(4))[0]
            type_flag = struct.unpack('<I', f.read(4))[0]
            dtype = "float" if type_flag == 1 else "bit"
            min_v = struct.unpack('<f', f.read(4))[0]
            max_v = struct.unpack('<f', f.read(4))[0]
            freq = struct.unpack('<f', f.read(4))[0]
            phase = struct.unpack('<f', f.read(4))[0]
            samples_per_500ms = struct.unpack('<I', f.read(4))[0]
            enabled_flag = struct.unpack('<I', f.read(4))[0]
            enabled = enabled_flag == 1
            
            param = Parameter(
                name=name, packet_id=packet_id, offset=offset, dtype=dtype,
                min_v=min_v, max_v=max_v, waveform="Sine", freq=freq, phase=phase,
                samples_per_500ms=samples_per_500ms, enabled=enabled,
                start_time=-900.0, end_time=1200.0
            )
            parameters.append(param)
        
        # Read separator
        separator = f.read(10)
        if separator != b'END_PARAMS':
            # Old format file, read as binary data only
            f.seek(0)
            return f.read(1400 * 10), []
        
        # Read binary data
        binary_data = f.read()
        return binary_data, parameters
```

#### Legacy CSV Support
```python
def load_csv(self, filepath):
    params = []
    with open(filepath, newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            param = Parameter(
                sl_no=int(row.get("sl_no", 0)),
                name=row["name"],
                packet_id=int(row["packet_id"]),
                dtype=row["type"],
                offset=int(row["offset"]),
                min_v=float(row.get("min", -1)),
                max_v=float(row.get("max", 1)),
                waveform=row.get("waveform", "Sine"),
                freq=float(row.get("freq", 1.0)),
                phase=float(row.get("phase", 0.0)),
                samples_per_500ms=int(row.get("samples_per_500ms", 1)),
                full_sweep=bool(row.get("full_sweep", True)),
                start_time=float(row.get("start_time", -900.0)),
                end_time=float(row.get("end_time", 1200.0)),
                fixed_value=float(row.get("fixed_value", 0.0)) if row.get("fixed_value") else None
            )
            param.enabled = True
            params.append(param)
    return params
```

### 2. JSON Configuration (utils/config.py)

```python
class ConfigManager:
    def save_config(self, filepath, parameters, simulation_settings):
        config = {
            "simulation_settings": simulation_settings,  # start_time, end_time, hz
            "parameters": [p.to_dict() for p in parameters]
        }
        with open(filepath, "w") as f:
            json.dump(config, f, indent=4)

    def load_config(self, filepath):
        with open(filepath, "r") as f:
            config = json.load(f)
        params = [Parameter.from_dict(p) for p in config["parameters"]]
        return config.get("simulation_settings", {}), params
```

## Network Transmission

### SenderThread (threads/sender_thread.py)

```python
class SenderThread(QThread):
    packet_sent = pyqtSignal(int, float)
    record_sent = pyqtSignal(int, float)
    bytes_sent_signal = pyqtSignal(int)
    error = pyqtSignal(str)

    def __init__(self, group="127.0.0.1", port=12345, ttl=1):
        super().__init__()
        self.group = group
        self.port = port
        self.ttl = ttl
        self.sock = None
        self.total_bytes = 0
        self._queue = []
        self.paused = False

    def configure_socket(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, self.ttl)

    def enqueue(self, record_idx, record_time, packets):
        self._queue.append((record_idx, packets))

    def run(self):
        self.running = True
        self.configure_socket()
        while self.running:
            if self.paused:
                self.msleep(50)
                continue
            if not self._queue:
                self.msleep(1)
                continue
            
            # Process all available records
            while self._queue and self.running and not self.paused:
                record_idx, packets = self._queue.pop(0)
                bytes_sent = 0
                for i, pkt in enumerate(packets):
                    try:
                        self.sock.sendto(pkt, (self.group, int(self.port)))
                        bytes_sent += len(pkt)
                        self.packet_sent.emit(i, time.time())
                    except Exception as e:
                        self.error.emit(str(e))
                self.total_bytes += bytes_sent
                self.bytes_sent_signal.emit(self.total_bytes)
                self.record_sent.emit(record_idx, time.time())
```

## Waveform Generation System

### Waveform Timing

- **Minor Cycle**: 5 samples per 500ms record, timestamps at record_time + i*0.1 (i=0 to 4)
- **Major Cycle**: 1 sample at record_time, fixed value (no waveform)

### Value Calculation

```python
# In SeedingEngine.seed_record
for i in range(5):  # Minor cycle
    sample_time = record_time + i * 0.1
    value = wf.value(sample_time, param.min_v, param.max_v)
    offset = param.offset + i * 4  # Sequential for floats
    buffer.insert_float(param.packet_id, offset, value)
```

### Supported Waveforms

1. **Sine**: `sin(2πft + φ)`
2. **Triangle**: Linear ramp up/down with period 1/f
3. **Square**: `sign(sin(2πft + φ))`
4. **Step**: Step function based on sine sign
5. **Noise**: Random uniform distribution [-1, 1]

## Real-time Plotting & Visualization

### Plot Updates

```python
def update_sample(self, name, t, y):
    if name not in self.curves:
        self.add_param(name)
    plot, data = self.curves[name]
    data["t"].append(t)
    data["y"].append(y)
    plot.setData(list(data["t"]), list(data["y"]))
```

### Data Management

- **Circular Buffers**: Use deque with maxlen=1000 for efficient memory management
- **Color Cycling**: 10 predefined colors for parameter differentiation
- **Marker Tracking**: Red circle marker shows current time position
- **Legend Support**: Automatic legend generation for parameter identification

### Graph Options

- **Zoom Controls**: Zoom in/out functionality
- **Export**: PNG export capability
- **Clear Plot**: Reset all curves and markers

## Error Handling & Logging

### Thread Error Handling

```python
try:
    buffer = self.seeding_engine.seed_record(params, current_time)
except Exception as e:
    self.error.emit(f"Seeder error: {str(e)}")
```

### File Loading Error Handling

```python
def on_browse_file(self):
    filename, _ = QFileDialog.getOpenFileName(self, "Load .dat File", "", "DAT Files (*.dat)")
    if filename:
        try:
            result = self.loader.load_dat(filename)
            # Process result...
        except Exception as e:
            self.log.append(f"Error loading file: {str(e)}")
```

### Network Error Handling

```python
try:
    self.sock.sendto(pkt, (self.group, int(self.port)))
    bytes_sent += len(pkt)
except Exception as e:
    self.error.emit(str(e))
```

## Configuration & State Management

### JSON Export

```python
def on_export_config(self):
    filename, _ = QFileDialog.getSaveFileName(self, "Save Config", "", "JSON Files (*.json)")
    if filename:
        settings = {
            "start_time": float(self.start_time_edit.text()),
            "end_time": float(self.end_time_edit.text()),
            "hz": float(self.hz_combo.currentText())
        }
        self.config_manager.save_config(filename, self.parameters, settings)
```

### Simulation Reset

```python
def on_reset(self):
    if self.seeder_thread:
        self.seeder_thread.stop()
    if self.sender_thread:
        self.sender_thread.stop()
    
    # Reset all counters and displays
    self.current_time_label.setText("Current Time: 0 sec")
    self.records_sent_label.setText("Records Sent: 0")
    self.bytes_sent_label.setText("Bytes Sent: 0")
    
    # Clear the waveform plot
    self.waveform_plot.clear_plot()
    
    # Reset parameter table instantaneous values
    for param in self.parameters:
        self.param_table.update_instantaneous(param.name, 0.0, 0.0)
    
    self.log.append("Simulation reset to initial state")
```

## Simulation Control & Timing Logic

### Transmission Hz Logic

The simulation rate is controlled by the Hz setting in the GUI:
- **1 Hz**: 1 record per second (sleep_time = 1.0 second)
- **2 Hz**: 2 records per second (sleep_time = 0.5 seconds)  
- **5 Hz**: 5 records per second (sleep_time = 0.2 seconds)
- **10 Hz**: 10 records per second (sleep_time = 0.1 seconds)
- **50 Hz**: 50 records per second (sleep_time = 0.02 seconds)

### Time Progression

- Each record advances simulation time by (1.0 / Hz) seconds
- Current time display updates in real-time
- Records sent counter increments with each transmission
- Bytes sent counter accumulates total data transmitted

### Pause/Resume Logic

Both SeederThread and SenderThread have synchronized pause/resume:
- **Pause**: Stops record generation AND transmission processing
- **Resume**: Continues from current simulation time
- **Reset**: Stops all threads, clears displays, resets to initial state

### Parameter Seeding Logic

#### Major Cycle (samples_per_500ms = 1)
- **Analog**: Single float value (4 bytes, <f) at record_time, using fixed_value or 0.0
- **Digital**: Single value with configurable bit-width (8-bit = 1 byte <B, 16-bit = 2 bytes <H, 32-bit = 4 bytes <I), stored as unsigned integer
- Updates parameter table with single instantaneous value

#### Minor Cycle (samples_per_500ms = 5)
- **Analog**: 5 float samples (4 bytes each, 20 bytes total), stored sequentially at param.offset + i*4, timestamps record_time + i*0.1
- **Digital**: 5 samples (8-bit each, stored in 8 bytes as uint64 <Q, 40 bytes total), stored sequentially at param.offset + i*8, timestamps record_time + i*0.1
- Updates parameter table with all 5 values separated by " | "

### File Structure (.dat format)

```
[4 bytes] Parameter count (<I)
[For each parameter:]
  [4 bytes] Name length (<I) + [Variable] Name (UTF-8)
  [4 bytes] Packet ID (<I) + [4 bytes] Offset (<I)
  [4 bytes] Type (1=float, 0=bit) (<I)
  [4 bytes] Min (<f) + [4 bytes] Max (<f) + [4 bytes] Freq (<f) + [4 bytes] Phase (<f)
  [4 bytes] Samples per 500ms (<I) + [4 bytes] Enabled flag (<I)
  [4 bytes] Bit width (8, 16, 32 for digital major, 8 for digital minor) (<I)
[10 bytes] "END_PARAMS" separator
[14000 bytes] 10 packets × 1400 bytes per record
```

### Real-time Updates

- **Current Time**: Updated from SeederThread.record_ready signal
- **Records Sent**: Updated from SenderThread.record_sent signal  
- **Bytes Sent**: Updated from SenderThread.bytes_sent_signal
- **Parameter Values**: Calculated and updated for each record
- **Waveform Plot**: Continuous plotting of enabled parameters

## Summary

The updated Telemetry Simulator provides:

- **Embedded Parameter Support**: .dat files with embedded parameter definitions (no external CSV required)
- **Dual Cycle Support**: Major cycle (1 sample) and minor cycle (5 samples) parameter generation
- **Synchronized Control**: Pause/resume across all threads with proper state management
- **Accurate Timing**: Hz-based timing with proper record generation rates
- **Real-time GUI**: Live statistics and parameter value updates
- **Manual Parameter Creation**: Add parameters without .dat files for testing
- **Complete Simulation Control**: Start/Pause/Resume/Reset functionality
- **State Persistence**: JSON export/import of complete simulation state
- **Robust Error Handling**: Comprehensive error handling and logging throughout

This implementation ensures proper timing, synchronized control, real-time feedback, and flexible parameter management as specified in the requirements.